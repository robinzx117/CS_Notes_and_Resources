A header file "stdbool.h" must be included to use bool in C.
#include <stdbool.h>
int main() {
    bool arr[2] = {true, false};
    return 0;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>

int main() {
    printf("Size of int : %d\n",   sizeof(int));
    printf("Size of char : %d\n",  sizeof(char));
    printf("Size of float : %d\n", sizeof(float));
    printf("Size of double : %d\n",sizeof(double));
    return 0;
}

Output:
Size of int : 4
Size of char : 1
Size of float : 4
Size of double : 8
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
char str[] = "Hello\0";
sizeof(str) is 7 - five bytes for the "Hello" text, plus the explicit NUL terminator, plus the implicit NUL terminator.
strlen(str) is 5 - the five "Hello" bytes only.
The key here is that the implicit nul terminator is always added - even if the string literal just happens to end with \0. Of course, strlen just stops at the first \0.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
%c: Character format specifier
%d, %i: Integer format specifier
%d and %i behave similar with printf. %d and %i behavior is different in scanf, %d assume base 10 while %i auto detects the base. 012 would be 10 with %i but 12 with %d.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
int scanf ( const char * format, ... );
-Read formatted data from stdin.

int printf ( const char * format, ... );
-Print formatted data to stdout.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
A typical memory representation of C program consists of following sections:
1. Text segment:
       -also known as a code segment or simply as text, is one of the sections of a program in an object file or in memory, which contains executable instructions. As a memory
        region, a text segment may be placed below the heap or stack in order to prevent heaps and stack overflows from overwriting it. Usually, the text segment is sharable so
        that only a single copy needs to be in memory for frequently executed programs, such as text editors, the C compiler, the shells, and so on. Also, the text segment is
        often read-only, to prevent a program from accidentally modifying its instructions.
2. Initialized data segment:
       -usually called simply the Data Segment. A data segment is a portion of virtual address space of a program, which contains the global variables and static variables that
        are initialized by the programmer. Note that, data segment is not read-only, since the values of the variables can be altered at run time. This segment can be further
        classified into initialized read-only area and initialized read-write area.
3. Uninitialized data segment:
       -often called the "bss" segment, named after an ancient assembler operator that stood for "block started by symbol." Data in this segment is initialized by the kernel to
        arithmetic 0 before the program starts executing. Uninitialized data starts at the end of the data segment and contains all global variables and static variables that
        are initialized to zero or do not have explicit initialization in source code.
4. Stack:
       -The stack area traditionally adjoined the heap area and grew the opposite direction; when the stack pointer met the heap pointer, free memory was exhausted. (With
        modern large address spaces and virtual memory techniques they may be placed almost anywhere, but they still typically grow opposite directions.)
        The stack area contains the program stack, a LIFO structure, typically located in the higher parts of memory. On the standard PC x86 computer architecture it grows
        toward address zero; on some other architectures it grows the opposite direction. A "stack pointer" register tracks the top of the stack; it is adjusted each time a
        value is "pushed" onto the stack.
5. Heap:
       -Heap is the segment where dynamic memory allocation usually takes place. The heap area begins at the end of the BSS segment and grows to larger addresses from there. The
        Heap area is managed by malloc, realloc, and free. The Heap area is shared by all shared libraries and dynamically loaded modules in a process.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
The size of void pointer varies system to system. If the system is 16-bit, size of void pointer is 2 bytes. If the system is 32-bit, size of void pointer is 4 bytes. If the
system is 64-bit, size of void pointer is 8 bytes.

#include <stdio.h>
int main() {
    void *ptr;
    printf("The size of pointer value : %d", sizeof(ptr));
    return 0;
}

Output:
The size of pointer value : 8 // 64-bit system

Double Pointer(Pointer to Pointer):
A pointer is used to store the address of variables. So, when we define a pointer to pointer, the first pointer is used to store the address of the second pointer.

#include<iostream>
int main() {
    int a = 17;
    int *p1;
    int **p2;
    p1 = &a;
    p2 = &p1;
    printf("Value of a = %d\n", a);
    printf("Value of a using single pointer = %d\n", *p1);
    printf("Value of a using double pointer = %d\n", **p2);
    return 0;
}

Output:
Value of a = 17
Value of a using single pointer = 17
Value of a using double pointer = 17

The sizeof() class with no virtual function inside it, is equal to the sum of all sizes of the member variable. For a class with one or more virtual functions the sizeof()
class is the sizeof() class plus the sizeof(void *). This extra size is for the hidden member called vptr which is a pointer, points to vtable.

class C1{
    short i;
    void funct();
};
class C2{
    short i;
    virtual void funct();
};
size of class C1 is 2 or sizeof(short).
size of class C2 is sizeof(short) + sizeof(void *) that is 2 + 4 = 6 for 32bit compiler. Because this extra 4 byte is used as a hidden vptr member of the class.
When we make a function as a virtual, compiler automatically set a hidden vptr as a class data member field.

Class without any data members and member function such type of class is known as empty class. Size of object of empty class is always 1 byte.
When we create object of any class at that time object always gets 3 characteristics:
    -State
    -Behaviour
    -Identity
When we create object of empty class at that time. State of that object is nothing. Behaviour of that object is also nothing, but compiler assigns a unique address to that
object. Memory in computer is always organized in the form of bytes and minimum memory available at object address location is 1 byte.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Arguments in C and C++ language are copied to the program stack at run time, where they are read by the function. These arguments can either be values in their own right, or they
can be pointers to areas of memory that contain the data being passed.
A Parameter is the symbolic name for "data" that goes into a function. There are two ways to pass parameters in C++: Pass by Value, Pass by Reference.
1.Pass by Value, means that a copy of the data is made and stored by way of the name of the parameter. Any changes to the parameter have NO affect on data in the calling
  function.
2.A reference parameter "refers" to the original data in the calling function. Thus any changes made to the parameter are ALSO MADE TO THE ORIGINAL variable.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*(asterisk) and &(ampersand) as type modifiers:
int i      - declares an int.
int* p     - declares a pointer to an int.
int& r = i - declares a reference to an int, and initializes it to reference i.
void foo(int i)  - declares a function taking an int (by value, i.e. as a copy).
void foo(int* p) - declares a function taking a pointer to an int.
void foo(int& r) - declares a function taking an int by reference. (C++ only)

// struct cpp *p
&(p->mem) is taking the address of the mem member of the struct pointed to by p.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
char str1[] = "string"; declares a char array of size 7 and initializes it with the characters: s,t,r,i,n,g and \0. You are allowed to modify the contents of this array.
char *str2  = "string"; declares str2 as a char pointer and initializes it with address of string literal "string" which is read-only. Modifying a string literal is an undefined
                       behavior. char* is a pointer reference. char* points to memory location where the contents are stored.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
If ptr points to an integer, ptr + 1 is the address of the next integer in memory after ptr. ptr - 1 is the address of the previous integer before ptr.
Note that ptr + 1 does not return the memory address after ptr, but the memory address of the next object of the type that ptr points to. If ptr points to an integer (assuming 4
bytes), ptr + 3 means 3 integers (12 bytes) after ptr. If ptr points to a char, which is always 1 byte, ptr + 3 means 3 chars (3 bytes) after ptr.
When calculating the result of a pointer arithmetic expression, the compiler always multiplies the integer operand by the size of the object being pointed to.
This is called scaling.

#include <iostream>
int main(){
    int num = 7;
    int *ptr = &num;
    std::cout<<ptr<<'\n';
    std::cout<<ptr+1<<'\n';
    std::cout<<ptr+2<<'\n';
    return 0;
}

Output:
0xfff000bd4
0xfff000bd8
0xfff000bdc
